<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å›½æ——ç‰¹å¾ç”Ÿæˆå™¨ (å¢å¼ºç‰ˆ - ä½¿ç”¨æœ€æ–°ä¼˜åŒ–ç®—æ³•)</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .progress {
            margin: 20px 0;
        }
        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background-color: #4CAF50;
            transition: width 0.3s ease;
        }
        .status {
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
        }
        .status.success { background-color: #d4edda; color: #155724; }
        .status.error { background-color: #f8d7da; color: #721c24; }
        .status.info { background-color: #d1ecf1; color: #0c5460; }
        .status.warning { background-color: #fff3cd; color: #856404; border: 1px solid #ffeaa7; }
        #results {
            margin-top: 20px;
            max-height: 300px;
            overflow-y: auto;
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 10px 5px;
        }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #6c757d; cursor: not-allowed; }
        .test-section {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
            margin: 20px 0;
        }
        .test-image {
            max-width: 60px;
            max-height: 45px;
            border: 1px solid #ddd;
            margin: 5px;
        }
        .feature-preview {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            font-size: 11px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸš€ å›½æ——ç‰¹å¾ç”Ÿæˆå™¨ (å¢å¼ºç‰ˆ)</h1>
        <p>ä½¿ç”¨æœ€æ–°ä¼˜åŒ–ç®—æ³•ç”Ÿæˆå›½æ——ç‰¹å¾ï¼ŒåŒ…å«å½¢çŠ¶æ£€æµ‹ã€é¢œè‰²æ¯”ä¾‹åˆ†æç­‰é«˜çº§åŠŸèƒ½ã€‚</p>

        <div class="status success">
            <strong>ğŸ¯ 2.0ç‰ˆæœ¬å‡çº§ï¼š</strong><br>
            â€¢ ä½¿ç”¨HSVé¢œè‰²ç©ºé—´ï¼ˆæ›´ç¬¦åˆäººçœ¼æ„ŸçŸ¥ï¼‰<br>
            â€¢ 10å•ä½é¢œè‰²ç²¾åº¦ï¼ˆä»25æå‡ï¼Œç²¾åº¦æé«˜2.5å€ï¼‰<br>
            â€¢ å¢å¼ºå¸ƒå±€æ£€æµ‹ï¼ˆ50æ¡é‡‡æ ·çº¿ï¼‰<br>
            â€¢ ç²¾ç¡®åœ†å½¢æ£€æµ‹ï¼ˆæ”¯æŒä»»æ„ä½ç½®å’Œå¤§å°ï¼‰<br>
            â€¢ æ–°å¢çº¹ç†ç‰¹å¾ã€å¯¹ç§°æ€§æ£€æµ‹ã€è§†è§‰é‡å¿ƒ<br>
            â€¢ çº¯è‰²å›½æ——ä¸“é—¨ä¼˜åŒ–å’Œå¾®å°å›¾æ¡ˆæ£€æµ‹
        </div>

        <div class="test-section">
            <h3>ğŸ§ª æµ‹è¯•å›¾ç‰‡åŠ è½½</h3>
            <p>æ£€æŸ¥å›½æ——å›¾ç‰‡æ˜¯å¦èƒ½æ­£å¸¸åŠ è½½ï¼š</p>
            <div id="testImages">
                <img src="../assets/images/flags/cn.png" class="test-image" alt="ä¸­å›½" onerror="this.style.border='2px solid red'">
                <img src="../assets/images/flags/us.png" class="test-image" alt="ç¾å›½" onerror="this.style.border='2px solid red'">
                <img src="../assets/images/flags/jp.png" class="test-image" alt="æ—¥æœ¬" onerror="this.style.border='2px solid red'">
                <img src="../assets/images/flags/fr.png" class="test-image" alt="æ³•å›½" onerror="this.style.border='2px solid red'">
                <img src="../assets/images/flags/bd.png" class="test-image" alt="å­ŸåŠ æ‹‰å›½" onerror="this.style.border='2px solid red'">
                <img src="../assets/images/flags/et.png" class="test-image" alt="åŸƒå¡ä¿„æ¯”äºš" onerror="this.style.border='2px solid red'">
            </div>
            <div id="testStatus"></div>
        </div>

        <button id="testBtn" onclick="testImageLoading()">ğŸ§ª æµ‹è¯•å›¾ç‰‡åŠ è½½</button>
        <button id="previewBtn" onclick="previewFeatures()" disabled>ğŸ” é¢„è§ˆç‰¹å¾æå–</button>
        <button id="startBtn" onclick="startGeneration()" disabled>ğŸš€ å¼€å§‹ç”Ÿæˆå…¨éƒ¨ç‰¹å¾</button>
        <button id="downloadBtn" onclick="downloadResults()" style="display: none;">ä¸‹è½½ç‰¹å¾æ–‡ä»¶</button>
        <button id="copyBtn" onclick="copyToClipboard()" style="display: none;">å¤åˆ¶åˆ°å‰ªè´´æ¿</button>

        <div class="progress" id="progressContainer" style="display: none;">
            <div>è¿›åº¦: <span id="progressText">0/0</span></div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill" style="width: 0%"></div>
            </div>
            <div>å½“å‰å¤„ç†: <span id="currentCountry">-</span></div>
            <div>æˆåŠŸ: <span id="successCount">0</span> | å¤±è´¥: <span id="errorCount">0</span></div>
        </div>

        <div id="featurePreview" class="feature-preview" style="display: none;"></div>
        <div id="results"></div>
    </div>

    <script>
        /**
         * 2.0ç‰ˆé«˜ç²¾åº¦ç‰¹å¾æå–å™¨ - HSVé¢œè‰²ç©ºé—´ + å¤šç»´åº¦ç‰¹å¾
         */
        class HighPrecisionFlagFeatureExtractor {
            constructor() {
                this.targetWidth = 150;
                this.targetHeight = 100;
                this.colorPrecision = 10; // æå‡åˆ°10å•ä½ç²¾åº¦
            }

            // RGBè½¬HSVé¢œè‰²ç©ºé—´
            rgbToHsv(r, g, b) {
                r /= 255;
                g /= 255;
                b /= 255;

                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                const diff = max - min;

                let h = 0;
                let s = max === 0 ? 0 : diff / max;
                let v = max;

                if (diff !== 0) {
                    switch (max) {
                        case r: h = ((g - b) / diff + (g < b ? 6 : 0)) / 6; break;
                        case g: h = ((b - r) / diff + 2) / 6; break;
                        case b: h = ((r - g) / diff + 4) / 6; break;
                    }
                }

                return {
                    h: Math.round(h * 360),
                    s: Math.round(s * 100),
                    v: Math.round(v * 100)
                };
            }

            // HSVé‡åŒ–åˆ°æŒ‡å®šç²¾åº¦
            quantizeHsv(h, s, v) {
                const hQuant = Math.floor(h / 15) * 15; // è‰²è°ƒ15åº¦ç²¾åº¦
                const sQuant = Math.floor(s / 10) * 10; // é¥±å’Œåº¦10%ç²¾åº¦
                const vQuant = Math.floor(v / this.colorPrecision) * this.colorPrecision; // æ˜åº¦10å•ä½ç²¾åº¦
                return `${hQuant},${sQuant},${vQuant}`;
            }

            async extractFeatures(imgElement) {
                try {
                    // åˆ›å»ºcanvaså¹¶ç»˜åˆ¶å›¾åƒ
                    const canvas = document.createElement('canvas');
                    canvas.width = this.targetWidth;
                    canvas.height = this.targetHeight;
                    const ctx = canvas.getContext('2d');

                    // è®¾ç½®èƒŒæ™¯è‰²ä¸ºç™½è‰²ï¼ˆå¤„ç†é€æ˜å›¾ç‰‡ï¼‰
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, this.targetWidth, this.targetHeight);

                    // ç¼©æ”¾å›¾åƒåˆ°ç›®æ ‡å°ºå¯¸
                    ctx.drawImage(imgElement, 0, 0, this.targetWidth, this.targetHeight);

                    // è·å–å›¾åƒæ•°æ®
                    const imageData = ctx.getImageData(0, 0, this.targetWidth, this.targetHeight);

                    // åˆ†æç‰¹å¾
                    return this.analyzeEnhancedFeatures(imageData);
                } catch (error) {
                    console.warn(`æå–å›¾åƒç‰¹å¾å¤±è´¥:`, error);
                    // è¿”å›é»˜è®¤ç‰¹å¾
                    return {
                        dominant: ['hsv(0,0,100)'],
                        distribution: [1.0],
                        layout: 'unknown',
                        shapes: {
                            hasCircle: false,
                            hasStripes: false,
                            hasStar: false,
                            hasCross: false
                        },
                        colorProportions: {
                            mainColorRatio: 1.0,
                            hasThreePlusColors: false
                        },
                        newFeatures: {
                            textureComplexity: 0,
                            symmetryScore: 0,
                            visualCenter: { x: 75, y: 50 },
                            preciseColors: []
                        }
                    };
                }
            }

            analyzeEnhancedFeatures(imageData) {
                const data = imageData.data;
                const hsvColorMap = new Map();
                const rgbColorMap = new Map();
                const pixels = [];

                // åˆ†æé¢œè‰²åˆ†å¸ƒ - ä½¿ç”¨HSVé¢œè‰²ç©ºé—´
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];

                    // HSVé‡åŒ–
                    const hsv = this.rgbToHsv(r, g, b);
                    const hsvColor = this.quantizeHsv(hsv.h, hsv.s, hsv.v);
                    hsvColorMap.set(hsvColor, (hsvColorMap.get(hsvColor) || 0) + 1);

                    // RGBç²¾ç¡®å€¼å­˜å‚¨ï¼ˆç”¨äºçº¯è‰²åŒ¹é…ï¼‰
                    const rgbColor = `${Math.floor(r/10)*10},${Math.floor(g/10)*10},${Math.floor(b/10)*10}`;
                    rgbColorMap.set(rgbColor, (rgbColorMap.get(rgbColor) || 0) + 1);

                    pixels.push({
                        x: (i / 4) % this.targetWidth,
                        y: Math.floor((i / 4) / this.targetWidth),
                        r, g, b, hsv
                    });
                }

                // è·å–HSVä¸»è¦é¢œè‰²
                const sortedHsvColors = Array.from(hsvColorMap.entries())
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 8); // å¢åŠ åˆ°8ä¸ªä¸»è¦é¢œè‰²

                const dominant = sortedHsvColors
                    .map(([color]) => `hsv(${color})`);

                // è®¡ç®—é¢œè‰²åˆ†å¸ƒç™¾åˆ†æ¯”
                const totalPixels = imageData.width * imageData.height;
                const distribution = sortedHsvColors
                    .map(([_, count]) => count / totalPixels);

                // RGBç²¾ç¡®é¢œè‰²ï¼ˆç”¨äºçº¯è‰²åŒ¹é…ï¼‰
                const preciseColors = Array.from(rgbColorMap.entries())
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 3)
                    .map(([color, count]) => ({
                        rgb: `rgb(${color})`,
                        ratio: count / totalPixels
                    }));

                // å¢å¼ºå¸ƒå±€æ£€æµ‹
                const layout = this.detectEnhancedLayout(imageData);

                // å¢å¼ºå½¢çŠ¶æ£€æµ‹
                const shapes = this.detectEnhancedShapes(imageData, hsvColorMap, pixels);

                // é¢œè‰²æ¯”ä¾‹åˆ†æ
                const colorProportions = this.analyzeColorProportions(distribution);

                // æ–°ç‰¹å¾ç»´åº¦
                const newFeatures = this.extractNewFeatures(pixels, imageData, distribution);

                return {
                    dominant: dominant,
                    distribution: distribution,
                    layout: layout,
                    shapes: shapes,
                    colorProportions: colorProportions,
                    newFeatures: newFeatures,
                    preciseColors: preciseColors // æ–°å¢ï¼šç²¾ç¡®RGBé¢œè‰²
                };
            }

            // å¢å¼ºå¸ƒå±€æ£€æµ‹ - 50æ¡é‡‡æ ·çº¿ + HSVé¢œè‰²ç©ºé—´
            detectEnhancedLayout(imageData) {
                const { data, width, height } = imageData;
                const sampleLines = 50; // å¢åŠ åˆ°50æ¡é‡‡æ ·çº¿

                // æ£€æŸ¥æ°´å¹³æ¡çº¹
                const horizontalPatterns = [];
                for (let y = 0; y < height; y += Math.floor(height / sampleLines)) {
                    let rowPattern = [];
                    for (let x = 0; x < width; x += 3) { // æ¯3ä¸ªåƒç´ é‡‡æ ·ä¸€æ¬¡
                        const i = (y * width + x) * 4;
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        const hsv = this.rgbToHsv(r, g, b);
                        rowPattern.push(this.quantizeHsv(hsv.h, hsv.s, hsv.v));
                    }
                    horizontalPatterns.push(rowPattern.join(','));
                }

                const uniqueHorizontalRows = new Set(horizontalPatterns).size;
                if (uniqueHorizontalRows <= 4) { // ç¨å¾®æ”¾å®½åˆ¤æ–­æ¡ä»¶
                    return 'horizontal';
                }

                // æ£€æŸ¥å‚ç›´æ¡çº¹
                const verticalPatterns = [];
                for (let x = 0; x < width; x += Math.floor(width / sampleLines)) {
                    let colPattern = [];
                    for (let y = 0; y < height; y += 3) {
                        const i = (y * width + x) * 4;
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        const hsv = this.rgbToHsv(r, g, b);
                        colPattern.push(this.quantizeHsv(hsv.h, hsv.s, hsv.v));
                    }
                    verticalPatterns.push(colPattern.join(','));
                }

                const uniqueVerticalCols = new Set(verticalPatterns).size;
                if (uniqueVerticalCols <= 4) {
                    return 'vertical';
                }

                // æ£€æŸ¥å¯¹è§’çº¿å›¾æ¡ˆ - å¢å¼ºé‡‡æ ·
                const diagonalPatterns1 = [];
                const diagonalPatterns2 = [];

                const diagonalSamples = Math.min(width, height) / 8; // å¢åŠ å¯¹è§’çº¿é‡‡æ ·ç‚¹
                for (let i = 0; i < diagonalSamples; i++) {
                    const step = Math.min(width, height) / diagonalSamples;

                    // å·¦ä¸Šåˆ°å³ä¸‹å¯¹è§’çº¿
                    const index1 = Math.floor(i * step);
                    const x1 = Math.min(index1, width - 1);
                    const y1 = Math.min(index1, height - 1);
                    const idx1 = (y1 * width + x1) * 4;
                    const r1 = data[idx1];
                    const g1 = data[idx1 + 1];
                    const b1 = data[idx1 + 2];
                    const hsv1 = this.rgbToHsv(r1, g1, b1);
                    diagonalPatterns1.push(this.quantizeHsv(hsv1.h, hsv1.s, hsv1.v));

                    // å³ä¸Šåˆ°å·¦ä¸‹å¯¹è§’çº¿
                    const x2 = Math.min(index1, width - 1);
                    const y2 = Math.min(height - 1 - index1, height - 1);
                    const idx2 = (y2 * width + x2) * 4;
                    const r2 = data[idx2];
                    const g2 = data[idx2 + 1];
                    const b2 = data[idx2 + 2];
                    const hsv2 = this.rgbToHsv(r2, g2, b2);
                    diagonalPatterns2.push(this.quantizeHsv(hsv2.h, hsv2.s, hsv2.v));
                }

                const uniqueDiagonal1 = new Set(diagonalPatterns1).size;
                const uniqueDiagonal2 = new Set(diagonalPatterns2).size;

                if (uniqueDiagonal1 <= 6 || uniqueDiagonal2 <= 6) {
                    return 'diagonal';
                }

                // æ£€æŸ¥çº¯è‰²å›½æ——
                const totalUniqueColors = new Set([...horizontalPatterns, ...verticalPatterns]).size;
                if (totalUniqueColors <= 3) {
                    return 'solid';
                }

                return 'complex';
            }

            // å¢å¼ºå½¢çŠ¶æ£€æµ‹ - æ”¯æŒä»»æ„ä½ç½®åœ†å½¢ï¼Œç²¾ç¡®æ£€æµ‹
            detectEnhancedShapes(imageData, hsvColorMap, pixels) {
                const shapes = {
                    hasCircle: false,
                    hasStripes: false,
                    hasStar: false,
                    hasCross: false,
                    circleInfo: null, // æ–°å¢ï¼šåœ†å½¢è¯¦ç»†ä¿¡æ¯
                    stripeInfo: null, // æ–°å¢ï¼šæ¡çº¹è¯¦ç»†ä¿¡æ¯
                    starInfo: null    // æ–°å¢ï¼šæ˜Ÿå½¢è¯¦ç»†ä¿¡æ¯
                };

                // æ£€æµ‹æ¡çº¹å›¾æ¡ˆï¼ˆåŸºäºå¸ƒå±€æ£€æµ‹ç»“æœï¼‰
                const layout = this.detectEnhancedLayout(imageData);
                shapes.hasStripes = layout === 'horizontal' || layout === 'vertical';
                shapes.stripeInfo = shapes.hasStripes ? { type: layout, count: this.countStripes(imageData) } : null;

                // æ£€æµ‹åœ†å½¢å›¾æ¡ˆ - æ”¯æŒä»»æ„ä½ç½®
                shapes.circleInfo = this.detectCircularPatternEnhanced(imageData, hsvColorMap, pixels);
                shapes.hasCircle = shapes.circleInfo !== null;

                // æ£€æµ‹æ˜Ÿå½¢å›¾æ¡ˆ - å¢å¼ºæ£€æµ‹
                shapes.starInfo = this.detectStarPatternEnhanced(imageData, hsvColorMap);
                shapes.hasStar = shapes.starInfo !== null;

                // æ£€æµ‹åå­—å›¾æ¡ˆ - å¢å¼ºæ£€æµ‹
                shapes.hasCross = this.detectCrossPatternEnhanced(imageData);

                return shapes;
            }

            // å¢å¼ºåœ†å½¢æ£€æµ‹ - æ”¯æŒä»»æ„ä½ç½®å’Œå¤§å°
            detectCircularPatternEnhanced(imageData, hsvColorMap, pixels) {
                const { width, height } = imageData;
                const minRadius = Math.min(width, height) * 0.05; // æœ€å°åŠå¾„
                const maxRadius = Math.min(width, height) * 0.3;  // æœ€å¤§åŠå¾„

                // è·å–ä¸»è¦å’Œæ¬¡è¦é¢œè‰²
                const sortedColors = Array.from(hsvColorMap.entries())
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 3);

                if (sortedColors.length < 2) return null;

                const mainColor = sortedColors[0][0];
                const secondaryColor = sortedColors[1][0];

                // æœç´¢å¯èƒ½çš„åœ†å½¢ä½ç½®
                const possibleCircles = [];

                // ä½¿ç”¨æ»‘åŠ¨çª—å£æœç´¢åœ†å½¢
                const step = 8;
                for (let cx = minRadius; cx < width - minRadius; cx += step) {
                    for (let cy = minRadius; cy < height - minRadius; cy += step) {
                        for (let radius = minRadius; radius <= maxRadius; radius += step * 0.5) {
                            const circleScore = this.evaluateCircle(imageData, cx, cy, radius, secondaryColor);
                            if (circleScore > 0.6) { // é˜ˆå€¼åˆ¤æ–­
                                possibleCircles.push({
                                    x: cx,
                                    y: cy,
                                    radius: radius,
                                    score: circleScore
                                });
                            }
                        }
                    }
                }

                if (possibleCircles.length > 0) {
                    // è¿”å›æœ€ä½³åŒ¹é…çš„åœ†å½¢
                    const bestCircle = possibleCircles.sort((a, b) => b.score - a.score)[0];
                    return {
                        centerX: bestCircle.x,
                        centerY: bestCircle.y,
                        radius: bestCircle.radius,
                        confidence: bestCircle.score
                    };
                }

                return null;
            }

            // è¯„ä¼°åœ†å½¢è´¨é‡
            evaluateCircle(imageData, centerX, centerY, radius, targetColor) {
                const { data, width, height } = imageData;
                let targetColorPixels = 0;
                let totalCirclePixels = 0;

                for (let y = Math.max(0, centerY - radius); y <= Math.min(height - 1, centerY + radius); y++) {
                    for (let x = Math.max(0, centerX - radius); x <= Math.min(width - 1, centerX + radius); x++) {
                        const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
                        if (distance <= radius) {
                            const i = (y * width + x) * 4;
                            const r = data[i];
                            const g = data[i + 1];
                            const b = data[i + 2];
                            const hsv = this.rgbToHsv(r, g, b);
                            const color = this.quantizeHsv(hsv.h, hsv.s, hsv.v);

                            totalCirclePixels++;
                            if (color === targetColor) {
                                targetColorPixels++;
                            }
                        }
                    }
                }

                return totalCirclePixels > 0 ? targetColorPixels / totalCirclePixels : 0;
            }

            // è®¡ç®—æ¡çº¹æ•°é‡
            countStripes(imageData) {
                const { data, width, height } = imageData;
                const stripeColors = new Set();

                // æ°´å¹³æ¡çº¹è®¡æ•°
                for (let y = 0; y < height; y += Math.floor(height / 10)) {
                    let rowColor = '';
                    for (let x = 0; x < width; x += 5) {
                        const i = (y * width + x) * 4;
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        const hsv = this.rgbToHsv(r, g, b);
                        rowColor += this.quantizeHsv(hsv.h, hsv.s, hsv.v);
                    }
                    stripeColors.add(rowColor);
                }

                return stripeColors.size;
            }

            // å¢å¼ºæ˜Ÿå½¢æ£€æµ‹
            detectStarPatternEnhanced(imageData, hsvColorMap) {
                const { data, width, height } = imageData;
                const minRadius = Math.min(width, height) * 0.03;

                // æ£€æµ‹è§’è½åŒºåŸŸçš„å¤æ‚é¢œè‰²æ¨¡å¼
                const corners = [
                    { x: 0, y: 0, w: width * 0.2, h: height * 0.2 },
                    { x: width * 0.8, y: 0, w: width * 0.2, h: height * 0.2 },
                    { x: 0, y: height * 0.8, w: width * 0.2, h: height * 0.2 },
                    { x: width * 0.8, y: height * 0.8, w: width * 0.2, h: height * 0.2 }
                ];

                let starScore = 0;
                for (const corner of corners) {
                    const uniqueColors = new Set();
                    let colorChangeCount = 0;
                    let lastColor = null;

                    // è¯¦ç»†æ‰«æè§’è½åŒºåŸŸ
                    for (let y = corner.y; y < corner.y + corner.h; y += 2) {
                        for (let x = corner.x; x < corner.x + corner.w; x += 2) {
                            const i = (y * width + x) * 4;
                            const r = data[i];
                            const g = data[i + 1];
                            const b = data[i + 2];
                            const hsv = this.rgbToHsv(r, g, b);
                            const color = this.quantizeHsv(hsv.h, hsv.s, hsv.v);

                            uniqueColors.add(color);
                            if (lastColor && lastColor !== color) {
                                colorChangeCount++;
                            }
                            lastColor = color;
                        }
                    }

                    // å¦‚æœè§’è½åŒºåŸŸé¢œè‰²å¤æ‚åº¦é«˜ï¼Œå¯èƒ½æ˜¯æ˜Ÿå½¢æˆ–å…¶ä»–å¤æ‚å›¾æ¡ˆ
                    if (uniqueColors.size > 4 && colorChangeCount > uniqueColors.size * 2) {
                        starScore++;
                    }
                }

                return starScore >= 2 ? {
                    detected: true,
                    corners: starScore,
                    confidence: Math.min(1.0, starScore / 3)
                } : null;
            }

            // å¢å¼ºåå­—æ£€æµ‹
            detectCrossPatternEnhanced(imageData) {
                const { data, width, height } = imageData;
                const centerX = Math.floor(width / 2);
                const centerY = Math.floor(height / 2);
                const crossWidth = Math.max(3, Math.min(width, height) / 15);

                let crossPixels = 0;
                let totalCrossArea = 0;

                // æ£€æµ‹æ°´å¹³å’Œå‚ç›´åå­—åŒºåŸŸ
                for (let x = centerX - crossWidth * 2; x <= centerX + crossWidth * 2; x++) {
                    for (let y = centerY - crossWidth; y <= centerY + crossWidth; y++) {
                        if (x >= 0 && x < width && y >= 0 && y < height) {
                            const i = (y * width + x) * 4;
                            const r = data[i];
                            const g = data[i + 1];
                            const b = data[i + 2];

                            // æ£€æµ‹åå­—çš„å…¸å‹é¢œè‰²ï¼ˆç™½è‰²ã€é»‘è‰²æˆ–é«˜å¯¹æ¯”åº¦ï¼‰
                            const isCrossColor = (r > 220 && g > 220 && b > 220) || // ç™½è‰²
                                               (r < 35 && g < 35 && b < 35) ||      // é»‘è‰²
                                               (Math.abs(r - g) < 30 && Math.abs(r - b) < 30); // ç°è‰²

                            if (isCrossColor) {
                                crossPixels++;
                            }
                            totalCrossArea++;
                        }
                    }
                }

                // å‚ç›´éƒ¨åˆ†
                for (let x = centerX - crossWidth; x <= centerX + crossWidth; x++) {
                    for (let y = centerY - crossWidth * 2; y <= centerY + crossWidth * 2; y++) {
                        if (x >= 0 && x < width && y >= 0 && y < height) {
                            const i = (y * width + x) * 4;
                            const r = data[i];
                            const g = data[i + 1];
                            const b = data[i + 2];

                            const isCrossColor = (r > 220 && g > 220 && b > 220) ||
                                               (r < 35 && g < 35 && b < 35) ||
                                               (Math.abs(r - g) < 30 && Math.abs(r - b) < 30);

                            if (isCrossColor) {
                                crossPixels++;
                            }
                            totalCrossArea++;
                        }
                    }
                }

                return totalCrossArea > 0 && crossPixels / totalCrossArea > 0.25;
            }

                // åˆ†æé¢œè‰²æ¯”ä¾‹
            analyzeColorProportions(distribution) {
                return {
                    mainColorRatio: distribution[0] || 0,
                    hasThreePlusColors: distribution.length >= 3 && distribution[2] > 0.05,
                    colorBalance: distribution.length > 1 ?
                        Math.min(...distribution.slice(1)) / Math.max(...distribution.slice(1)) : 0,
                    totalColors: distribution.length
                };
            }

            // æ–°ç‰¹å¾ç»´åº¦æå– - çº¹ç†ã€å¯¹ç§°æ€§ã€è§†è§‰é‡å¿ƒ
            extractNewFeatures(pixels, imageData, distribution) {
                const { width, height } = imageData;

                // 1. çº¹ç†å¤æ‚åº¦åˆ†æ
                const textureComplexity = this.calculateTextureComplexity(imageData);

                // 2. å¯¹ç§°æ€§æ£€æµ‹
                const symmetryScore = this.calculateSymmetryScore(imageData);

                // 3. è§†è§‰é‡å¿ƒè®¡ç®—
                const visualCenter = this.calculateVisualCenter(pixels, width, height);

                // 4. é¢œè‰²æ¢¯åº¦åˆ†æ
                const gradientStrength = this.calculateGradientStrength(imageData);

                // 5. è¾¹ç¼˜å¤æ‚åº¦
                const edgeComplexity = this.calculateEdgeComplexity(imageData);

                return {
                    textureComplexity: textureComplexity,
                    symmetryScore: symmetryScore,
                    visualCenter: visualCenter,
                    gradientStrength: gradientStrength,
                    edgeComplexity: edgeComplexity,
                    isPureColor: distribution[0] > 0.95 // çº¯è‰²åˆ¤æ–­
                };
            }

            // è®¡ç®—çº¹ç†å¤æ‚åº¦
            calculateTextureComplexity(imageData) {
                const { data, width, height } = imageData;
                let totalColorDiff = 0;
                let comparisons = 0;

                // è®¡ç®—ç›¸é‚»åƒç´ çš„é¢œè‰²å·®å¼‚
                for (let y = 0; y < height - 1; y += 2) {
                    for (let x = 0; x < width - 1; x += 2) {
                        const i = (y * width + x) * 4;

                        // æ°´å¹³æ¯”è¾ƒ
                        const iRight = (y * width + x + 1) * 4;
                        const horizDiff = Math.abs(data[i] - data[iRight]) +
                                       Math.abs(data[i + 1] - data[iRight + 1]) +
                                       Math.abs(data[i + 2] - data[iRight + 2]);

                        // å‚ç›´æ¯”è¾ƒ
                        const iBottom = ((y + 1) * width + x) * 4;
                        const vertDiff = Math.abs(data[i] - data[iBottom]) +
                                      Math.abs(data[i + 1] - data[iBottom + 1]) +
                                      Math.abs(data[i + 2] - data[iBottom + 2]);

                        totalColorDiff += Math.min(horizDiff, vertDiff);
                        comparisons++;
                    }
                }

                return comparisons > 0 ? totalColorDiff / (comparisons * 255 * 3) : 0;
            }

            // è®¡ç®—å¯¹ç§°æ€§å¾—åˆ†
            calculateSymmetryScore(imageData) {
                const { data, width, height } = imageData;
                let horizontalSymmetry = 0;
                let verticalSymmetry = 0;

                // æ°´å¹³å¯¹ç§°æ€§ï¼ˆä¸Šä¸‹å¯¹ç§°ï¼‰
                for (let y = 0; y < height / 2; y++) {
                    for (let x = 0; x < width; x++) {
                        const iTop = (y * width + x) * 4;
                        const iBottom = ((height - 1 - y) * width + x) * 4;

                        const diff = Math.abs(data[iTop] - data[iBottom]) +
                                   Math.abs(data[iTop + 1] - data[iBottom + 1]) +
                                   Math.abs(data[iTop + 2] - data[iBottom + 2]);

                        horizontalSymmetry += 1 - (diff / (255 * 3));
                    }
                }

                // å‚ç›´å¯¹ç§°æ€§ï¼ˆå·¦å³å¯¹ç§°ï¼‰
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width / 2; x++) {
                        const iLeft = (y * width + x) * 4;
                        const iRight = (y * width + (width - 1 - x)) * 4;

                        const diff = Math.abs(data[iLeft] - data[iRight]) +
                                   Math.abs(data[iLeft + 1] - data[iRight + 1]) +
                                   Math.abs(data[iLeft + 2] - data[iRight + 2]);

                        verticalSymmetry += 1 - (diff / (255 * 3));
                    }
                }

                const hScore = horizontalSymmetry / ((height / 2) * width);
                const vScore = verticalSymmetry / (height * (width / 2));

                return {
                    horizontal: hScore,
                    vertical: vScore,
                    overall: (hScore + vScore) / 2
                };
            }

            // è®¡ç®—è§†è§‰é‡å¿ƒ
            calculateVisualCenter(pixels, width, height) {
                let totalWeight = 0;
                let weightedX = 0;
                let weightedY = 0;

                // ä½¿ç”¨äº®åº¦ä½œä¸ºæƒé‡
                for (const pixel of pixels) {
                    const brightness = (pixel.r + pixel.g + pixel.b) / 3;
                    const weight = 255 - brightness; // æš—è‰²åŒºåŸŸæƒé‡æ›´é«˜

                    weightedX += pixel.x * weight;
                    weightedY += pixel.y * weight;
                    totalWeight += weight;
                }

                if (totalWeight > 0) {
                    return {
                        x: Math.round(weightedX / totalWeight),
                        y: Math.round(weightedY / totalWeight),
                        isCentered: false
                    };
                }

                return { x: width / 2, y: height / 2, isCentered: true };
            }

            // è®¡ç®—é¢œè‰²æ¢¯åº¦å¼ºåº¦
            calculateGradientStrength(imageData) {
                const { data, width, height } = imageData;
                let totalGradient = 0;
                let gradientCount = 0;

                // Sobelè¾¹ç¼˜æ£€æµ‹ç®€åŒ–ç‰ˆ
                for (let y = 1; y < height - 1; y += 2) {
                    for (let x = 1; x < width - 1; x += 2) {
                        const i = (y * width + x) * 4;

                        // Xæ–¹å‘æ¢¯åº¦
                        const iLeft = (y * width + (x - 1)) * 4;
                        const iRight = (y * width + (x + 1)) * 4;
                        const gradX = Math.abs(
                            (data[iLeft] + data[iLeft + 1] + data[iLeft + 2]) -
                            (data[iRight] + data[iRight + 1] + data[iRight + 2])
                        );

                        // Yæ–¹å‘æ¢¯åº¦
                        const iTop = ((y - 1) * width + x) * 4;
                        const iBottom = ((y + 1) * width + x) * 4;
                        const gradY = Math.abs(
                            (data[iTop] + data[iTop + 1] + data[iTop + 2]) -
                            (data[iBottom] + data[iBottom + 1] + data[iBottom + 2])
                        );

                        totalGradient += Math.sqrt(gradX * gradX + gradY * gradY);
                        gradientCount++;
                    }
                }

                return gradientCount > 0 ? totalGradient / gradientCount : 0;
            }

            // è®¡ç®—è¾¹ç¼˜å¤æ‚åº¦
            calculateEdgeComplexity(imageData) {
                const { data, width, height } = imageData;
                const threshold = 30; // è¾¹ç¼˜æ£€æµ‹é˜ˆå€¼
                let edgePixels = 0;
                let totalChecked = 0;

                for (let y = 1; y < height - 1; y += 2) {
                    for (let x = 1; x < width - 1; x += 2) {
                        const i = (y * width + x) * 4;
                        const centerBrightness = (data[i] + data[i + 1] + data[i + 2]) / 3;

                        // æ£€æŸ¥8ä¸ªé‚»å±…
                        const neighbors = [
                            ((y - 1) * width + (x - 1)) * 4,
                            ((y - 1) * width + x) * 4,
                            ((y - 1) * width + (x + 1)) * 4,
                            (y * width + (x - 1)) * 4,
                            (y * width + (x + 1)) * 4,
                            ((y + 1) * width + (x - 1)) * 4,
                            ((y + 1) * width + x) * 4,
                            ((y + 1) * width + (x + 1)) * 4
                        ];

                        let significantDiff = 0;
                        for (const ni of neighbors) {
                            const neighborBrightness = (data[ni] + data[ni + 1] + data[ni + 2]) / 3;
                            if (Math.abs(centerBrightness - neighborBrightness) > threshold) {
                                significantDiff++;
                            }
                        }

                        if (significantDiff > 2) {
                            edgePixels++;
                        }
                        totalChecked++;
                    }
                }

                return totalChecked > 0 ? edgePixels / totalChecked : 0;
            }
        }

        // å…¨å±€å˜é‡
        let countries = [];
        let flagFeatures = {};
        let extractor = new HighPrecisionFlagFeatureExtractor();

        // æµ‹è¯•å›¾ç‰‡åŠ è½½
        async function testImageLoading() {
            const testBtn = document.getElementById('testBtn');
            const testStatus = document.getElementById('testStatus');
            const previewBtn = document.getElementById('previewBtn');

            testBtn.disabled = true;
            testStatus.innerHTML = '<div class="status info">æ­£åœ¨æµ‹è¯•å›¾ç‰‡åŠ è½½...</div>';

            try {
                const testCountries = ['cn', 'us', 'jp', 'fr', 'bd', 'et'];
                let successCount = 0;
                let errorCount = 0;

                for (const code of testCountries) {
                    try {
                        const img = new Image();
                        img.crossOrigin = 'anonymous';
                        await new Promise((resolve, reject) => {
                            img.onload = resolve;
                            img.onerror = reject;
                            img.src = `../assets/images/flags/${code}.png`;
                        });
                        successCount++;
                    } catch (error) {
                        errorCount++;
                        console.error(`Failed to load ${code}:`, error);
                    }
                }

                if (successCount > 0) {
                    testStatus.innerHTML = `<div class="status success">âœ… å›¾ç‰‡åŠ è½½æµ‹è¯•é€šè¿‡ï¼æˆåŠŸ: ${successCount}, å¤±è´¥: ${errorCount}</div>`;
                    previewBtn.disabled = false;
                } else {
                    testStatus.innerHTML = `<div class="status error">âŒ å›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥assets/images/flagsç›®å½•æ˜¯å¦å­˜åœ¨</div>`;
                }

            } catch (error) {
                testStatus.innerHTML = `<div class="status error">âŒ æµ‹è¯•å¤±è´¥: ${error.message}</div>`;
            }

            testBtn.disabled = false;
        }

        // é¢„è§ˆç‰¹å¾æå–
        async function previewFeatures() {
            const previewBtn = document.getElementById('previewBtn');
            const featurePreview = document.getElementById('featurePreview');
            const startBtn = document.getElementById('startBtn');

            previewBtn.disabled = true;
            featurePreview.style.display = 'block';
            featurePreview.innerHTML = '<div class="status info">æ­£åœ¨æå–ç‰¹å¾é¢„è§ˆ...</div>';

            try {
                // æµ‹è¯•å‡ ä¸ªå…³é”®å›½å®¶çš„ç‰¹å¾æå–
                const testCountries = [
                    { code: 'bd', name: 'å­ŸåŠ æ‹‰å›½' },
                    { code: 'et', name: 'åŸƒå¡ä¿„æ¯”äºš' },
                    { code: 'jp', name: 'æ—¥æœ¬' },
                    { code: 'fr', name: 'æ³•å›½' }
                ];

                let previewHTML = '<h4>ğŸ” ç‰¹å¾æå–é¢„è§ˆï¼š</h4>';

                for (const testCountry of testCountries) {
                    try {
                        const img = new Image();
                        img.crossOrigin = 'anonymous';
                        await new Promise((resolve, reject) => {
                            img.onload = resolve;
                            img.onerror = reject;
                            img.src = `../assets/images/flags/${testCountry.code}.png`;
                        });

                        const features = await extractor.extractFeatures(img);

                        // æ˜¾ç¤ºä¼ ç»Ÿç‰¹å¾
                        const shapeInfo = [];
                        if (features.shapes.hasCircle) shapeInfo.push(`åœ†å½¢(${features.shapes.circleInfo.confidence.toFixed(2)})`);
                        if (features.shapes.hasStripes) shapeInfo.push(`æ¡çº¹(${features.shapes.stripeInfo.count})`);
                        if (features.shapes.hasStar) shapeInfo.push(`æ˜Ÿå½¢(${features.shapes.starInfo.confidence.toFixed(2)})`);
                        if (features.shapes.hasCross) shapeInfo.push('åå­—');

                        previewHTML += `
                            <div style="margin: 10px 0; padding: 8px; background: #e9ecef; border-radius: 4px;">
                                <strong>${testCountry.name} (${testCountry.code.toUpperCase()})</strong><br>
                                <strong>HSVä¸»è¦é¢œè‰²:</strong> ${features.dominant.slice(0, 3).join(', ')}<br>
                                <strong>å¸ƒå±€:</strong> ${features.layout}<br>
                                <strong>å½¢çŠ¶:</strong> ${shapeInfo.join(' | ') || 'æ— '}<br>
                                <strong>é¢œè‰²æ¯”ä¾‹:</strong> ä¸»è‰²${(features.colorProportions.mainColorRatio * 100).toFixed(1)}% |
                                                å¤šè‰²${features.colorProportions.hasThreePlusColors ? 'âœ“' : 'âœ—'}<br>
                        `;

                        // æ˜¾ç¤ºæ–°ç‰¹å¾ç»´åº¦
                        if (features.newFeatures) {
                            previewHTML += `
                                <strong>æ–°ç‰¹å¾ç»´åº¦:</strong><br>
                                â€¢ çº¹ç†å¤æ‚åº¦: ${(features.newFeatures.textureComplexity * 100).toFixed(1)}%<br>
                                â€¢ å¯¹ç§°æ€§: æ€»ä½“${(features.newFeatures.symmetryScore.overall * 100).toFixed(1)}% |
                                          æ°´å¹³${(features.newFeatures.symmetryScore.horizontal * 100).toFixed(1)}% |
                                          å‚ç›´${(features.newFeatures.symmetryScore.vertical * 100).toFixed(1)}%<br>
                                â€¢ è§†è§‰é‡å¿ƒ: (${features.newFeatures.visualCenter.x}, ${features.newFeatures.visualCenter.y})<br>
                                â€¢ æ¢¯åº¦å¼ºåº¦: ${features.newFeatures.gradientStrength.toFixed(1)}<br>
                                â€¢ è¾¹ç¼˜å¤æ‚åº¦: ${(features.newFeatures.edgeComplexity * 100).toFixed(1)}%<br>
                                â€¢ çº¯è‰²åˆ¤æ–­: ${features.newFeatures.isPureColor ? 'æ˜¯' : 'å¦'}<br>
                            `;
                        }

                        // æ˜¾ç¤ºç²¾ç¡®é¢œè‰²
                        if (features.preciseColors && features.preciseColors.length > 0) {
                            previewHTML += `
                                <strong>ç²¾ç¡®RGBé¢œè‰²:</strong><br>
                                ${features.preciseColors.map((c, i) => `${c.rgb} (${(c.ratio * 100).toFixed(1)}%)`).join(' | ')}<br>
                            `;
                        }

                        previewHTML += `</div>`;
                    } catch (error) {
                        previewHTML += `
                            <div style="margin: 10px 0; padding: 8px; background: #f8d7da; border-radius: 4px;">
                                <strong>${testCountry.name} (${testCountry.code.toUpperCase()})</strong><br>
                                âŒ ç‰¹å¾æå–å¤±è´¥: ${error.message}
                            </div>
                        `;
                    }
                }

                featurePreview.innerHTML = previewHTML;
                startBtn.disabled = false;

            } catch (error) {
                featurePreview.innerHTML = `<div class="status error">é¢„è§ˆå¤±è´¥: ${error.message}</div>`;
            }

            previewBtn.disabled = false;
        }

        // åŠ è½½å›½å®¶æ•°æ®
        async function loadCountries() {
            try {
                const response = await fetch('../data/countries/countries_un.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                countries = data.countries || data;
                log(`å·²åŠ è½½ ${countries.length} ä¸ªå›½å®¶/åœ°åŒºæ•°æ®`);
                return true;
            } catch (error) {
                log(`åŠ è½½å›½å®¶æ•°æ®å¤±è´¥: ${error.message}`, 'error');
                return false;
            }
        }

        // ç”Ÿæˆç‰¹å¾
        async function startGeneration() {
            const startBtn = document.getElementById('startBtn');
            const progressContainer = document.getElementById('progressContainer');
            const resultsDiv = document.getElementById('results');

            startBtn.disabled = true;
            progressContainer.style.display = 'block';
            resultsDiv.innerHTML = '';

            log('å¼€å§‹ç”Ÿæˆå¢å¼ºç‰ˆå›½æ——ç‰¹å¾...', 'info');

            // åŠ è½½å›½å®¶æ•°æ®
            if (!await loadCountries()) {
                startBtn.disabled = false;
                return;
            }

            const totalCountries = countries.length;
            let processedCount = 0;
            let successCount = 0;
            let errorCount = 0;

            updateProgress(0, totalCountries, 0, 0);

            // å¤„ç†æ¯ä¸ªå›½å®¶
            for (let i = 0; i < totalCountries; i++) {
                const country = countries[i];

                try {
                    document.getElementById('currentCountry').textContent =
                        `${country.nameCN} (${country.code})`;

                    const img = new Image();
                    img.crossOrigin = 'anonymous';

                    try {
                        await new Promise((resolve, reject) => {
                            img.onload = resolve;
                            img.onerror = reject;
                            img.src = `../assets/images/flags/${country.code.toLowerCase()}.png`;
                        });

                        const features = await extractor.extractFeatures(img);

                        flagFeatures[country.code] = {
                            dominant: features.dominant,
                            distribution: features.distribution,
                            layout: features.layout,
                            shapes: features.shapes,
                            colorProportions: features.colorProportions,
                            country: {
                                code: country.code,
                                nameCN: country.nameCN,
                                nameEN: country.nameEN
                            }
                        };

                        successCount++;
                        log(`âœ… ${country.nameCN} - å¢å¼ºç‰¹å¾æå–å®Œæˆ`);

                    } catch (imgError) {
                        errorCount++;
                        log(`âŒ ${country.nameCN} - å›¾ç‰‡åŠ è½½å¤±è´¥: ${imgError.message}`, 'error');
                    }

                    processedCount++;

                } catch (error) {
                    errorCount++;
                    log(`âŒ ${country.nameCN} - å¤„ç†å¤±è´¥: ${error.message}`, 'error');
                }

                updateProgress(processedCount, totalCountries, successCount, errorCount);

                if (i % 5 === 0) {
                    await new Promise(resolve => setTimeout(resolve, 50));
                }
            }

            const outputData = {
                metadata: {
                    generatedAt: new Date().toISOString(),
                    totalCountries: countries.length,
                    processedCount: successCount,
                    errorCount: errorCount,
                    version: '2.0.0-HSV-HighPrecision',
                    note: '2.0ç‰ˆé«˜ç²¾åº¦ç‰¹å¾ç”Ÿæˆå™¨ - HSVé¢œè‰²ç©ºé—´ + 10å•ä½ç²¾åº¦ + å¤šç»´åº¦ç‰¹å¾',
                    features: {
                        colorSpace: 'HSV',
                        colorPrecision: 10,
                        sampleLines: 50,
                        newDimensions: [
                            'textureComplexity',
                            'symmetryScore',
                            'visualCenter',
                            'gradientStrength',
                            'edgeComplexity',
                            'preciseColors'
                        ],
                        enhancedDetection: [
                            'arbitraryPositionCircles',
                            'enhancedStarDetection',
                            'improvedCrossDetection',
                            'solidColorSpecialization'
                        ]
                    }
                },
                features: flagFeatures
            };

            window.flagFeaturesResult = JSON.stringify(outputData, null, 2);

            document.getElementById('downloadBtn').style.display = 'inline-block';
            document.getElementById('copyBtn').style.display = 'inline-block';

            log(`ğŸ‰ å¢å¼ºç‰ˆç‰¹å¾ç”Ÿæˆå®Œæˆï¼`, 'success');
            log(`ğŸ“Š å¤„ç†ç»“æœ:`, 'info');
            log(`   - æ€»å›½å®¶æ•°: ${countries.length}`, 'info');
            log(`   - æˆåŠŸå¤„ç†: ${successCount}`, 'success');
            log(`   - å¤„ç†å¤±è´¥: ${errorCount}`, errorCount > 0 ? 'error' : 'info');
            log(`   - JSONå¤§å°: ${(window.flagFeaturesResult.length / 1024).toFixed(2)} KB`, 'info');

            startBtn.disabled = false;
        }

        function updateProgress(current, total, success, error) {
            const percentage = Math.round((current / total) * 100);
            document.getElementById('progressText').textContent = `${current}/${total}`;
            document.getElementById('progressFill').style.width = `${percentage}%`;
            document.getElementById('successCount').textContent = success;
            document.getElementById('errorCount').textContent = error;
        }

        function downloadResults() {
            if (!window.flagFeaturesResult) return;

            const blob = new Blob([window.flagFeaturesResult], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'flag-features-enhanced.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            log('ğŸ“ å¢å¼ºç‰ˆç‰¹å¾æ–‡ä»¶å·²ä¸‹è½½', 'success');
        }

        async function copyToClipboard() {
            if (!window.flagFeaturesResult) return;

            try {
                await navigator.clipboard.writeText(window.flagFeaturesResult);
                log('ğŸ“‹ å¢å¼ºç‰ˆç‰¹å¾æ•°æ®å·²å¤åˆ¶åˆ°å‰ªè´´æ¿', 'success');
            } catch (error) {
                log(`å¤åˆ¶å¤±è´¥: ${error.message}`, 'error');
            }
        }

        function log(message, type = 'info') {
            const resultsDiv = document.getElementById('results');
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = `status ${type}`;
            logEntry.innerHTML = `<strong>[${timestamp}]</strong> ${message}`;
            resultsDiv.appendChild(logEntry);
            resultsDiv.scrollTop = resultsDiv.scrollHeight;
        }

        document.addEventListener('DOMContentLoaded', function() {
            log('ğŸ¯ 2.0ç‰ˆé«˜ç²¾åº¦ç‰¹å¾ç”Ÿæˆå™¨å·²å°±ç»ª', 'info');
            log('æ ¸å¿ƒå‡çº§: HSVé¢œè‰²ç©ºé—´ + 10å•ä½ç²¾åº¦ + å¤šç»´åº¦ç‰¹å¾', 'info');
            log('æ–°åŠŸèƒ½: ä»»æ„ä½ç½®åœ†å½¢æ£€æµ‹ã€çº¹ç†åˆ†æã€å¯¹ç§°æ€§æ£€æµ‹ã€è§†è§‰é‡å¿ƒ', 'info');
            log('è¯·å…ˆæµ‹è¯•å›¾ç‰‡åŠ è½½ï¼Œç„¶åé¢„è§ˆç‰¹å¾æå–', 'info');
        });
    </script>
</body>
</html>